<html>
    <head>
        <link rel='stylesheet' href='css.css'>
        <stlye>

        </stlye>
    </head>
    <body onload="document.getElementById('x').checked = false; document.getElementById('y').checked = false; document.getElementById('z').checked = false;">

<h1 align="center">Rotating Orthographic Cube Using Rotation Matrix</h1>

<!-- <input type="button" id="ortho" onclick="orthographicx()" value="orthographic view (x-axis)">
<input type="button" id="ortho" onclick="orthographicy()" value="orthographic view (y-axis)">
<input type="button" id="ortho" onclick="orthographicz()" value="orthographic view (z-axis)"> -->

Axes of rotation:<br>

x-axis<input type="checkbox" id="x" onclick="xboolf()">
y-axis<input type="checkbox" id="y" onclick="yboolf()">
z-axis<input type="checkbox" id="z" onclick="zboolf()">
<input type="button" id="startf" value="start" onclick="start()"><br>

<!-- <input type="button" id="perspect" onclick="perspective()" value="perspective view"><br> -->


<canvas id="ctx" width="500" height="500" style="border:1px solid #000000; background-color: rgb(230, 230, 230)"></canvas>


<script>
    var c = document.getElementById("ctx")
    var ctx = c.getContext("2d")

    let x1 = 10
    let y1 = 10
    let z1 = 10
     
    let x2 = -10
    let y2 = 10
    let z2 = 10

    let x3 = -10
    let y3 = -10
    let z3 = 10

    let x4 = 10
    let y4 = -10
    let z4 = 10

    let x5 = 10
    let y5 = 10
    let z5 = -10
     
    let x6 = -10
    let y6 = 10
    let z6 = -10

    let x7 = -10
    let y7 = -10
    let z7 = -10

    let x8 = 10
    let y8 = -10
    let z8 = -10

    let cx = 250
    let cy = 250
    let cz = 250

    let xbool = 0
    let ybool = 0
    let zbool = 0

    function xboolf() {
        if (xbool == 0) {
            xbool = 1
        }
        else if (xbool == 1) {
            xbool = 0
        }
    }

    function yboolf() {
        if (ybool == 0) {
            ybool = 1
        }
        else if (ybool == 1) {
            ybool = 0
        }
    }

    function zboolf() {
        if (zbool == 0) {
            zbool = 1
        }
        else if (zbool == 1) {
            zbool = 0
        }
    }

    function start() {

        let x = xbool
        let y = ybool
        let z = zbool


        if (x == 1 && y == 0 && z == 0) {            //100
            orthographicx()
        } else if (x == 0 && y == 0 && z == 1) {     //001
            orthographicz()

        } else if (x == 0 && y == 1 && z == 0) {     //010
            orthographicy()

        } else if (x == 0 && y == 1 && z == 1) {      //011
            orthographicy()
            orthographicz()

        } else if (x == 1 && y == 0 && z == 1) {      //101
            orthographicx()
            orthographicz()

        } else if (x == 1 && y == 1 && z == 0) {      //110
            orthographicx()
            orthographicz()

        } else if (x == 1 && y == 1 && z == 1) {     //111
            orthographicx()
            orthographicy()
            orthographicz()


        }
    }

function orthographicz() {

    const sleep = (time) => {
    return new Promise((resolve) => setTimeout(resolve, 1))
}

const something = async () => {

    for (i = 0; i <= 360; i++){
        await sleep(1)

        console.log(i)
        ctx.beginPath();
        ctx.clearRect(0, 0, 1000, 1000)
        ctx.stroke();

        theta = (0.5 * Math.PI) / 180

        x1 = ((x1 * Math.cos(theta)) - (y1 * Math.sin(theta)))
        y1 = ((x1 * Math.sin(theta)) + (y1 * Math.cos(theta)))
        z1 = (x1 * 0) + (y1 * 0) + (z1 * 1)

        x2 = ((x2 * Math.cos(theta)) - (y2 * Math.sin(theta)))
        y2 = ((x2 * Math.sin(theta)) + (y2 * Math.cos(theta)))
        z2 = (x2 * 0) + (y2 * 0) + (z2 * 1)

        x3 = ((x3 * Math.cos(theta)) - (y3 * Math.sin(theta)))
        y3 = ((x3 * Math.sin(theta)) + (y3 * Math.cos(theta)))
        z3 = (x3 * 0) + (y3 * 0) + (z3 * 1)

        x4 = ((x4 * Math.cos(theta)) - (y4 * Math.sin(theta)))
        y4 = ((x4 * Math.sin(theta)) + (y4 * Math.cos(theta)))
        z4 = (x4 * 0) + (y4 * 0) + (z4 * 1)

        x5 = ((x5 * Math.cos(theta)) - (y5 * Math.sin(theta)))
        y5 = ((x5 * Math.sin(theta)) + (y5 * Math.cos(theta)))
        z5 = (x5 * 0) + (y5 * 0) + (z5 * 1)

        x6 = ((x6 * Math.cos(theta)) - (y6 * Math.sin(theta)))
        y6 = ((x6 * Math.sin(theta)) + (y6 * Math.cos(theta)))
        z6 = (x6 * 0) + (y6 * 0) + (z6 * 1)

        x7 = ((x7 * Math.cos(theta)) - (y7 * Math.sin(theta)))
        y7 = ((x7 * Math.sin(theta)) + (y7 * Math.cos(theta)))
        z7 = (x7 * 0) + (y7 * 0) + (z7 * 1)

        x8 = ((x8 * Math.cos(theta)) - (y8 * Math.sin(theta)))
        y8 = ((x8 * Math.sin(theta)) + (y8 * Math.cos(theta)))
        z8 = (x8 * 0) + (y8 * 0) + (z8 * 1)


        ctx.beginPath();
    ctx.moveTo(x1 * 5 + cx, y1 * 5 + cy, z1 * 5 + cz);
    ctx.lineTo(x2 * 5 + cx, y2 * 5 + cy, z2 * 5 + cz);
    ctx.lineTo(x3 * 5 + cx, y3 * 5 + cy, z3 * 5 + cz);
    ctx.lineTo(x4 * 5 + cx, y4 * 5 + cy, z4 * 5 + cz);
    ctx.lineTo(x1 * 5 + cx, y1 * 5 + cy, z1 * 5 + cz);

    ctx.moveTo(x5 * 5 + cx, y5 * 5 + cy, z5 * 5 + cz);
    ctx.lineTo(x6 * 5 + cx, y6 * 5 + cy, z6 * 5 + cz);
    ctx.lineTo(x7 * 5 + cx, y7 * 5 + cy, z7 * 5 + cz);
    ctx.lineTo(x8 * 5 + cx, y8 * 5 + cy, z8 * 5 + cz);
    ctx.lineTo(x5 * 5 + cx, y5 * 5 + cy, z5 * 5 + cz);

    ctx.moveTo(x1 * 5 + cx, y1 * 5 + cy, z1 * 5 + cz)
    ctx.lineTo(x5 * 5 + cx, y5 * 5 + cy, z5 * 5 + cz)

    ctx.moveTo(x2 * 5 + cx, y2 * 5 + cy, z2 * 5 + cz)
    ctx.lineTo(x6 * 5 + cx, y6 * 5 + cy, z6 * 5 + cz)

    ctx.moveTo(x3 * 5 + cx, y3 * 5 + cy, z3 * 5 + cz)
    ctx.lineTo(x7 * 5 + cx, y7 * 5 + cy, z7 * 5 + cz)

    ctx.moveTo(x4 * 5 + cx, y4 * 5 + cy, z4 * 5 + cz)
    ctx.lineTo(x8 * 5 + cx, y8 * 5 + cy, z8 * 5 + cz)

    ctx.stroke();

if (i == 360) {
    i = 0
}

    }

}
something()
}

function orthographicy() {

const sleep = (time) => {
return new Promise((resolve) => setTimeout(resolve, 1))
}

const something = async () => {

for (i = 0; i <= 360; i++){
    await sleep(1)

    ctx.beginPath();
    ctx.clearRect(0, 0, 1000, 1000)
    ctx.stroke();

    theta = (0.5 * Math.PI) / 180

   x1 = (x1 * Math.cos(theta) + (y1 * 0) + (z1 * Math.sin(theta)))
   y1 = (x1 * 0) + (y1 * 1) + (z1 * 0)
   z1 = (-x1 * Math.sin(theta)) + (y1 * 0) + (z1 * Math.cos(theta))

   x2 = (x2 * Math.cos(theta) + (y2 * 0) + (z2 * Math.sin(theta)))
   y2 = (x2 * 0) + (y2 * 1) + (z2 * 0)
   z2 = (-x2 * Math.sin(theta)) + (y2 * 0) + (z2 * Math.cos(theta))

   x3 = (x3 * Math.cos(theta) + (y3 * 0) + (z3 * Math.sin(theta)))
   y3 = (x3 * 0) + (y3 * 1) + (z3 * 0)
   z3 = (-x3 * Math.sin(theta)) + (y3 * 0) + (z3 * Math.cos(theta))

   x4 = (x4 * Math.cos(theta) + (y4 * 0) + (z4 * Math.sin(theta)))
   y4 = (x4 * 0) + (y4 * 1) + (z4 * 0)
   z4 = (-x4 * Math.sin(theta)) + (y4 * 0) + (z4 * Math.cos(theta))

   x5 = (x5 * Math.cos(theta) + (y5 * 0) + (z5 * Math.sin(theta)))
   y5 = (x5 * 0) + (y5 * 1) + (z5 * 0)
   z5 = (-x5 * Math.sin(theta)) + (y5 * 0) + (z5 * Math.cos(theta))

   x6 = (x6 * Math.cos(theta) + (y6 * 0) + (z6 * Math.sin(theta)))
   y6 = (x6 * 0) + (y6 * 1) + (z6 * 0)
   z6 = (-x6 * Math.sin(theta)) + (y6 * 0) + (z6 * Math.cos(theta))

   x7 = (x7 * Math.cos(theta) + (y7 * 0) + (z7 * Math.sin(theta)))
   y7 = (x7 * 0) + (y7 * 1) + (z7 * 0)
   z7 = (-x7 * Math.sin(theta)) + (y7 * 0) + (z7 * Math.cos(theta))

   x8 = (x8 * Math.cos(theta) + (y8 * 0) + (z8 * Math.sin(theta)))
   y8 = (x8 * 0) + (y8 * 1) + (z8 * 0)
   z8 = (-x8 * Math.sin(theta)) + (y8 * 0) + (z8 * Math.cos(theta))




    ctx.beginPath();
    ctx.moveTo(x1 * 5 + cx, y1 * 5 + cy, z1 * 5 + cz);
    ctx.lineTo(x2 * 5 + cx, y2 * 5 + cy, z2 * 5 + cz);
    ctx.lineTo(x3 * 5 + cx, y3 * 5 + cy, z3 * 5 + cz);
    ctx.lineTo(x4 * 5 + cx, y4 * 5 + cy, z4 * 5 + cz);
    ctx.lineTo(x1 * 5 + cx, y1 * 5 + cy, z1 * 5 + cz);

    ctx.moveTo(x5 * 5 + cx, y5 * 5 + cy, z5 * 5 + cz);
    ctx.lineTo(x6 * 5 + cx, y6 * 5 + cy, z6 * 5 + cz);
    ctx.lineTo(x7 * 5 + cx, y7 * 5 + cy, z7 * 5 + cz);
    ctx.lineTo(x8 * 5 + cx, y8 * 5 + cy, z8 * 5 + cz);
    ctx.lineTo(x5 * 5 + cx, y5 * 5 + cy, z5 * 5 + cz);

    ctx.moveTo(x1 * 5 + cx, y1 * 5 + cy, z1 * 5 + cz)
    ctx.lineTo(x5 * 5 + cx, y5 * 5 + cy, z5 * 5 + cz)

    ctx.moveTo(x2 * 5 + cx, y2 * 5 + cy, z2 * 5 + cz)
    ctx.lineTo(x6 * 5 + cx, y6 * 5 + cy, z6 * 5 + cz)

    ctx.moveTo(x3 * 5 + cx, y3 * 5 + cy, z3 * 5 + cz)
    ctx.lineTo(x7 * 5 + cx, y7 * 5 + cy, z7 * 5 + cz)

    ctx.moveTo(x4 * 5 + cx, y4 * 5 + cy, z4 * 5 + cz)
    ctx.lineTo(x8 * 5 + cx, y8 * 5 + cy, z8 * 5 + cz)

    ctx.stroke();

    if (i == 360) {
    i = 0
}

}

}
something()
}

function orthographicx() {

const sleep = (time) => {
return new Promise((resolve) => setTimeout(resolve, 1))
}

const something = async () => {

for (i = 0; i <= 360; i++){
    await sleep(1)

    ctx.beginPath();
    ctx.clearRect(0, 0, 1000, 1000)
    ctx.stroke();

    theta = (0.5 * Math.PI) / 180

    x1 = (x1 * 1) + (y1 * 0) + (z1 * 0)
    y1 = (x1 * 0) + (y1 * Math.cos(theta)) + (-z1 * Math.sin(theta))
    z1 = (x1 * 0) + (y1 * Math.sin(theta)) + (z1 * Math.cos(theta))

    x2 = (x2 * 1) + (y2 * 0) + (z2 * 0)
    y2 = (x2 * 0) + (y2 * Math.cos(theta)) - (z2 * Math.sin(theta))
    z2 = (x2 * 0) + (y2 * Math.sin(theta)) + (z2 * Math.cos(theta))
    
    x3 = (x3 * 1) + (y3 * 0) + (z3 * 0)
    y3 = (x3 * 0) + (y3 * Math.cos(theta)) - (z3 * Math.sin(theta))
    z3 = (x3 * 0) + (y3 * Math.sin(theta)) + (z3 * Math.cos(theta))
    
    x4 = (x4 * 1) + (y4 * 0) + (z4 * 0)
    y4 = (x4 * 0) + (y4 * Math.cos(theta)) - (z4 * Math.sin(theta))
    z4 = (x4 * 0) + (y4 * Math.sin(theta)) + (z4 * Math.cos(theta))

    x5 = (x5 * 1) + (y5 * 0) + (z5 * 0)
    y5 = (x5 * 0) + (y5 * Math.cos(theta)) - (z5 * Math.sin(theta))
    z5 = (x5 * 0) + (y5 * Math.sin(theta)) + (z5 * Math.cos(theta))
    
    x6 = (x6 * 1) + (y6 * 0) + (z6 * 0)
    y6 = (x6 * 0) + (y6 * Math.cos(theta)) - (z6 * Math.sin(theta))
    z6 = (x6 * 0) + (y6 * Math.sin(theta)) + (z6 * Math.cos(theta))
    
    x7 = (x7 * 1) + (y7 * 0) + (z7 * 0)
    y7 = (x7 * 0) + (y7 * Math.cos(theta)) - (z7 * Math.sin(theta))
    z7 = (x7 * 0) + (y7 * Math.sin(theta)) + (z7 * Math.cos(theta))
    
    x8 = (x8 * 1) + (y8 * 0) + (z8 * 0)
    y8 = (x8 * 0) + (y8 * Math.cos(theta)) - (z8 * Math.sin(theta))
    z8 = (x8 * 0) + (y8 * Math.sin(theta)) + (z8 * Math.cos(theta))
  




    ctx.beginPath();
    
    ctx.moveTo(x1 * 5 + cx, y1 * 5 + cy, z1 * 5 + cz);
    ctx.lineTo(x2 * 5 + cx, y2 * 5 + cy, z2 * 5 + cz);
    ctx.lineTo(x3 * 5 + cx, y3 * 5 + cy, z3 * 5 + cz);
    ctx.lineTo(x4 * 5 + cx, y4 * 5 + cy, z4 * 5 + cz);
    ctx.lineTo(x1 * 5 + cx, y1 * 5 + cy, z1 * 5 + cz);

    ctx.moveTo(x5 * 5 + cx, y5 * 5 + cy, z5 * 5 + cz);
    ctx.lineTo(x6 * 5 + cx, y6 * 5 + cy, z6 * 5 + cz);
    ctx.lineTo(x7 * 5 + cx, y7 * 5 + cy, z7 * 5 + cz);
    ctx.lineTo(x8 * 5 + cx, y8 * 5 + cy, z8 * 5 + cz);
    ctx.lineTo(x5 * 5 + cx, y5 * 5 + cy, z5 * 5 + cz);

    ctx.moveTo(x1 * 5 + cx, y1 * 5 + cy, z1 * 5 + cz)
    ctx.lineTo(x5 * 5 + cx, y5 * 5 + cy, z5 * 5 + cz)

    ctx.moveTo(x2 * 5 + cx, y2 * 5 + cy, z2 * 5 + cz)
    ctx.lineTo(x6 * 5 + cx, y6 * 5 + cy, z6 * 5 + cz)

    ctx.moveTo(x3 * 5 + cx, y3 * 5 + cy, z3 * 5 + cz)
    ctx.lineTo(x7 * 5 + cx, y7 * 5 + cy, z7 * 5 + cz)

    ctx.moveTo(x4 * 5 + cx, y4 * 5 + cy, z4 * 5 + cz)
    ctx.lineTo(x8 * 5 + cx, y8 * 5 + cy, z8 * 5 + cz)

    ctx.stroke();

if (i == 360) {
    i = 0
}

}

}
something()
}
</script>
</body>
</html>